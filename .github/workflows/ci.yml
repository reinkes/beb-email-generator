name: üöÄ CI/CD Pipeline

on:
  push:
    branches: [ main, develop ]
  pull_request:
    branches: [ main ]
  release:
    types: [published]

jobs:
  test:
    name: üß™ Run Tests
    runs-on: ubuntu-latest

    steps:
    - name: üì• Checkout code
      uses: actions/checkout@v6

    - name: üîç Debug environment
      run: |
        echo "üîç Debugging environment..."
        echo "Current directory: $(pwd)"
        echo "Directory contents:"
        ls -la
        echo "Node.js version: $(node --version || echo 'Node.js not available')"
        echo "Python version: $(python3 --version)"

    - name: üß™ Validate JavaScript files
      run: |
        echo "üß™ Running JavaScript validation..."

        # Check if js directory exists
        if [ ! -d "js" ]; then
          echo "‚ùå js directory not found"
          echo "Available directories:"
          find . -type d -maxdepth 2
          exit 1
        fi

        echo "‚úÖ js directory found"
        echo "Contents of js directory:"
        ls -la js/

        # Count JS files
        js_file_count=$(find js/ -name "*.js" | wc -l)
        echo "üìÅ Found $js_file_count JavaScript files"

        if [ $js_file_count -eq 0 ]; then
          echo "‚ùå No JavaScript files found in js/ directory"
          exit 1
        fi

        # List all JS files
        echo "üìã JavaScript files found:"
        find js/ -name "*.js"

        # Validate each JS file
        syntax_errors=0
        for file in js/*.js; do
          if [ -f "$file" ]; then
            echo "‚úÖ Found: $file"

            # Check file size
            file_size=$(wc -c < "$file")
            echo "üìè Size: $file_size bytes"

            if [ $file_size -eq 0 ]; then
              echo "‚ö†Ô∏è Empty file: $file"
              continue
            fi

            # Show first few lines for debugging
            echo "üìÑ First 3 lines of $file:"
            head -3 "$file"

            # Basic syntax check using node
            echo "üîç Checking syntax for $file..."
            if node -c "$file" 2>&1; then
              echo "‚úÖ Syntax OK: $file"
            else
              echo "‚ùå Syntax Error in $file"
              echo "Error details:"
              node -c "$file"
              syntax_errors=$((syntax_errors + 1))
            fi
          fi
        done

        if [ $syntax_errors -gt 0 ]; then
          echo "‚ùå Found $syntax_errors syntax errors"
          exit 1
        fi

        echo "‚úÖ All JavaScript files validated successfully"

    - name: üåê Setup simple HTTP server
      run: |
        echo "üåê Starting HTTP server..."

        # Start Python HTTP server in background
        python3 -m http.server 8080 > server.log 2>&1 &
        SERVER_PID=$!
        echo $SERVER_PID > server.pid
        echo "üìù Server PID: $SERVER_PID"

        # Wait for server to start
        sleep 5

        # Check if server process is still running
        if ! kill -0 $SERVER_PID 2>/dev/null; then
          echo "‚ùå Server process died"
          cat server.log
          exit 1
        fi

        # Test if server is responding
        for i in {1..5}; do
          if curl -f -s http://localhost:8080/ > /dev/null 2>&1; then
            echo "‚úÖ Server is running and responding"
            break
          else
            echo "‚è≥ Waiting for server to respond (attempt $i/5)"
            sleep 2
          fi

          if [ $i -eq 5 ]; then
            echo "‚ùå Server failed to respond after 5 attempts"
            cat server.log
            exit 1
          fi
        done

    - name: üß™ Run browser tests with curl
      run: |
        echo "üß™ Running browser compatibility tests..."

        test_failures=0

        # Test main page loads
        if curl -f -s http://localhost:8080/index.html > /dev/null 2>&1; then
          echo "‚úÖ Main page loads"
        else
          echo "‚ùå Main page failed to load"
          test_failures=$((test_failures + 1))
        fi

        # Test test page loads (optional, don't fail if missing)
        if curl -f -s http://localhost:8080/tests/test.html > /dev/null 2>&1; then
          echo "‚úÖ Test page loads"
        else
          echo "‚ö†Ô∏è Test page not accessible (optional)"
        fi

        # Test JS modules load
        for file in js/*.js; do
          if [ -f "$file" ]; then
            if curl -f -s "http://localhost:8080/$file" > /dev/null 2>&1; then
              echo "‚úÖ Module loads: $file"
            else
              echo "‚ùå Module failed to load: $file"
              test_failures=$((test_failures + 1))
            fi
          fi
        done

        # Test that main page contains expected content
        if curl -s http://localhost:8080/index.html | grep -q "BEB.*Email.*Generator"; then
          echo "‚úÖ Main page contains expected content"
        else
          echo "‚ùå Main page missing expected content"
          test_failures=$((test_failures + 1))
        fi

        if [ $test_failures -gt 0 ]; then
          echo "‚ùå Found $test_failures test failures"
          exit 1
        fi

        echo "‚úÖ All browser compatibility tests passed"

    - name: üìä Validate HTML structure
      run: |
        echo "üìä Running HTML validation..."

        # Basic HTML structure validation using grep
        if grep -q "<!DOCTYPE html>" index.html; then
          echo "‚úÖ DOCTYPE declaration found"
        else
          echo "‚ùå DOCTYPE declaration missing"
          exit 1
        fi

        if grep -q "<html" index.html; then
          echo "‚úÖ HTML tag found"
        else
          echo "‚ùå HTML tag missing"
          exit 1
        fi

        if grep -q "</html>" index.html; then
          echo "‚úÖ Closing HTML tag found"
        else
          echo "‚ùå Closing HTML tag missing"
          exit 1
        fi

        echo "‚úÖ HTML validation completed"

    - name: üîç Security scan
      run: |
        echo "üîç Running security checks..."

        # Check for common security issues
        if grep -r "eval(" js/ 2>/dev/null; then
          echo "‚ùå Found eval() usage - security risk"
          exit 1
        fi

        if grep -r "innerHTML.*+" js/ 2>/dev/null; then
          echo "‚ùå Found dynamic innerHTML - potential XSS risk"
          exit 1
        fi

        # Check for script tags in HTML that might be vulnerable
        if grep -r "<script.*src=" index.html | grep -v "js/"; then
          echo "‚ö†Ô∏è Found external script references"
        fi

        # Check for hardcoded credentials (more precise patterns)
        echo "üîç Scanning for hardcoded credentials..."

        # Look for suspicious credential patterns
        suspicious_patterns_found=0

        # Check for actual password assignments
        if grep -r "password\s*=\s*['\"]" js/ --include="*.js" 2>/dev/null; then
          echo "‚ùå Found hardcoded password assignment"
          suspicious_patterns_found=$((suspicious_patterns_found + 1))
        fi

        # Check for API keys (but exclude our legitimate encryption/cache keys)
        if grep -ri "api_key\|apikey\|access_key\|secret_key" js/ --include="*.js" | grep -v "encryptionKey\|cacheKey\|STORAGE_KEY" 2>/dev/null; then
          echo "‚ùå Found potential API keys"
          suspicious_patterns_found=$((suspicious_patterns_found + 1))
        fi

        # Check for hardcoded tokens
        if grep -ri "token\s*=\s*['\"][a-zA-Z0-9]{20,}" js/ --include="*.js" 2>/dev/null; then
          echo "‚ùå Found potential hardcoded tokens"
          suspicious_patterns_found=$((suspicious_patterns_found + 1))
        fi

        # Check for database credentials
        if grep -ri "db_password\|database.*password\|mysql.*password" js/ --include="*.js" 2>/dev/null; then
          echo "‚ùå Found potential database credentials"
          suspicious_patterns_found=$((suspicious_patterns_found + 1))
        fi

        if [ $suspicious_patterns_found -gt 0 ]; then
          echo "‚ùå Found $suspicious_patterns_found potential security issues"
          exit 1
        fi

        echo "‚úÖ No hardcoded credentials found"

        echo "‚úÖ Basic security checks passed"

    - name: üìè Code quality checks
      run: |
        echo "üìè Running code quality checks..."

        # Check file sizes
        HTML_SIZE=$(wc -c < index.html)
        if [ $HTML_SIZE -gt 100000 ]; then
          echo "‚ö†Ô∏è HTML file is large: ${HTML_SIZE} bytes"
        fi

        # Count JavaScript modules
        JS_FILES=$(find js/ -name "*.js" | wc -l)
        echo "üì¶ JavaScript modules: $JS_FILES"

        # Check for TODO comments in production code
        TODO_COUNT=$(grep -r "TODO\|FIXME\|HACK" js/ | wc -l)
        if [ $TODO_COUNT -gt 0 ]; then
          echo "üìù Found $TODO_COUNT TODO/FIXME comments"
        fi

        echo "‚úÖ Code quality checks completed"

    - name: üßπ Clean up server
      run: |
        # Kill the HTTP server
        if [ -f server.pid ]; then
          kill $(cat server.pid) 2>/dev/null || echo "Server already stopped"
          rm -f server.pid
        fi

  accessibility:
    name: ‚ôø Accessibility Tests
    runs-on: ubuntu-latest
    needs: test

    steps:
    - name: üì• Checkout code
      uses: actions/checkout@v6

    - name: ‚ôø Basic accessibility checks
      run: |
        echo "‚ôø Running basic accessibility checks..."

        # Check for alt attributes on images
        if grep -r "<img" index.html | grep -v "alt="; then
          echo "‚ö†Ô∏è Found images without alt attributes"
        else
          echo "‚úÖ All images have alt attributes"
        fi

        # Check for proper heading structure
        if grep -q "<h1" index.html; then
          echo "‚úÖ H1 heading found"
        else
          echo "‚ö†Ô∏è No H1 heading found"
        fi

        # Check for form labels
        if grep -r "<input" index.html | grep -v "aria-label\|<label"; then
          echo "‚ö†Ô∏è Found inputs without labels"
        else
          echo "‚úÖ All inputs have labels or aria-labels"
        fi

        # Check for ARIA attributes
        if grep -q "aria-" index.html; then
          echo "‚úÖ ARIA attributes found"
        else
          echo "‚ö†Ô∏è No ARIA attributes found"
        fi

        echo "‚úÖ Basic accessibility checks completed"

  performance:
    name: ‚ö° Performance Tests
    runs-on: ubuntu-latest
    needs: test

    steps:
    - name: üì• Checkout code
      uses: actions/checkout@v6

    - name: ‚ö° Basic performance checks
      run: |
        echo "‚ö° Running basic performance checks..."

        # Check file sizes
        HTML_SIZE=$(wc -c < index.html | tr -d ' ')
        echo "üìÑ HTML size: ${HTML_SIZE} bytes"
        if [ $HTML_SIZE -gt 100000 ]; then
          echo "‚ö†Ô∏è HTML file is large: ${HTML_SIZE} bytes"
        fi

        # Check JavaScript file sizes
        total_js_size=0
        for file in js/*.js; do
          if [ -f "$file" ]; then
            size=$(wc -c < "$file" | tr -d ' ')
            echo "üìÑ $file: ${size} bytes"
            total_js_size=$((total_js_size + size))
          fi
        done
        echo "üìÑ Total JavaScript: ${total_js_size} bytes"

        # Count HTTP requests (approximate)
        js_files=$(find js/ -name "*.js" | wc -l)
        echo "üì° JavaScript modules: $js_files"

        # Check for performance best practices
        if grep -q "defer\|async" index.html; then
          echo "‚úÖ Script loading optimization found"
        else
          echo "‚ö†Ô∏è Consider adding defer/async to scripts"
        fi

        echo "‚úÖ Basic performance checks completed"

  deploy-staging:
    name: üöÄ Deploy to Staging
    runs-on: ubuntu-latest
    needs: [test, accessibility, performance]
    if: github.ref == 'refs/heads/develop'

    steps:
    - name: üì• Checkout code
      uses: actions/checkout@v6

    - name: üöÄ Deploy to staging
      run: |
        echo "üöÄ Deploying to staging environment..."
        echo "‚úÖ Staging deployment completed"
        # Add actual deployment commands here

  deploy-production:
    name: üåê Deploy to Production
    runs-on: ubuntu-latest
    needs: [test, accessibility, performance]
    if: github.ref == 'refs/heads/main' && github.event_name == 'push'

    steps:
    - name: üì• Checkout code
      uses: actions/checkout@v6

    - name: üì¶ Prepare deployment package
      run: |
        echo "üì¶ Preparing deployment package..."

        # Create deployment directory
        mkdir -p deploy

        # Copy essential files
        cp index.html deploy/
        cp -r js/ deploy/

        # Copy optional files if they exist
        [ -f robots.txt ] && cp robots.txt deploy/ || echo "No robots.txt found"
        [ -f favicon.ico ] && cp favicon.ico deploy/ || echo "No favicon.ico found"
        [ -f manifest.json ] && cp manifest.json deploy/ || echo "No manifest.json found"

        # Create deployment info
        echo "{
          \"version\": \"$(date +%Y%m%d-%H%M%S)\",
          \"commit\": \"$GITHUB_SHA\",
          \"branch\": \"$GITHUB_REF_NAME\",
          \"timestamp\": \"$(date -u)\",
          \"build_number\": \"$GITHUB_RUN_NUMBER\"
        }" > deploy/deployment-info.json

        echo "üìã Deployment package contents:"
        find deploy/ -type f

    - name: üöÄ Deploy via SFTP/FTP (if configured)
      if: env.FTP_HOST != ''
      timeout-minutes: 15
      continue-on-error: true
      run: |
        echo "üöÄ Deploying via SFTP/FTP to $FTP_HOST..."

        # Debug configuration (without revealing sensitive data)
        echo "üìã Configuration check:"
        echo "  - Host: $FTP_HOST"
        echo "  - User: ${FTP_USER:0:3}***"
        echo "  - Path: $FTP_PATH"
        echo "  - Password: ${FTP_PASSWORD:+[SET]}${FTP_PASSWORD:-[NOT SET]}"

        # Install lftp for IONOS SFTP deployment
        sudo apt-get update -qq
        sudo apt-get install -y lftp

        # Create SSH config for better compatibility
        mkdir -p ~/.ssh
        cat > ~/.ssh/config << EOF
        Host *
            StrictHostKeyChecking no
            UserKnownHostsFile /dev/null
            ServerAliveInterval 60
            ServerAliveCountMax 3
            ConnectTimeout 30
        EOF
        chmod 600 ~/.ssh/config

        # Test IONOS SFTP connectivity
        echo "üîç Testing IONOS SFTP connectivity..."
        if timeout 10 nc -zv $FTP_HOST 22 2>/dev/null; then
          echo "‚úÖ IONOS SFTP port 22 is reachable"
          SFTP_AVAILABLE=true
        else
          echo "‚ùå IONOS SFTP port 22 not reachable"
          SFTP_AVAILABLE=false
        fi

        DEPLOY_SUCCESS=false

        # IONOS SFTP Deployment (simplified, no fallbacks)
        if [ "$SFTP_AVAILABLE" = true ]; then
          echo "üîê Deploying to IONOS via SFTP..."

          # Simple IONOS SFTP deployment
          timeout 180 lftp -c "
            set net:timeout 30
            set net:max-retries 2
            set sftp:auto-confirm yes
            set sftp:connect-program 'ssh -o StrictHostKeyChecking=no -o UserKnownHostsFile=/dev/null'
            set cmd:fail-exit yes

            echo 'Connecting to IONOS SFTP...'
            open sftp://$FTP_USER:$FTP_PASSWORD@$FTP_HOST

            echo 'Connected! Current directory:'
            pwd

            echo 'Changing to local deploy directory...'
            lcd deploy

            echo 'Starting file upload...'
            mirror --reverse --delete --verbose

            echo 'IONOS SFTP deployment completed!'
            quit
          "

          if [ $? -eq 0 ]; then
            echo "‚úÖ IONOS SFTP deployment successful!"
            DEPLOY_SUCCESS=true
          else
            echo "‚ùå IONOS SFTP deployment failed"
            DEPLOY_SUCCESS=false
          fi
        else
          echo "‚ùå SFTP port not reachable"
          DEPLOY_SUCCESS=false
        fi


        # Final status check
        if [ "$DEPLOY_SUCCESS" = true ]; then
          echo "üéâ Deployment completed successfully!"
        else
          echo "‚ùå All deployment methods failed"
          echo ""
          echo "üîç Troubleshooting information:"
          echo "  - SFTP available: $SFTP_AVAILABLE"
          echo "  - FTP available: $FTP_AVAILABLE"
          echo ""
          echo "üí° Common solutions:"
          echo "  1. Check that FTP_USER and FTP_PASSWORD are correct in GitHub Secrets"
          echo "  2. Verify FTP_HOST is the correct hostname (without http:// or ftp://)"
          echo "  3. Ensure your hosting provider allows SFTP/FTP connections from GitHub IPs"
          echo "  4. Check if your password contains special characters that need escaping"
          echo "  5. Verify FTP_PATH points to the correct directory"
          echo ""
          echo "üîß Debug commands you can run locally:"
          echo "  sftp $FTP_USER@$FTP_HOST"
          echo "  lftp sftp://$FTP_USER@$FTP_HOST"

          exit 1
        fi
      env:
        FTP_HOST: ${{ secrets.FTP_HOST }}
        FTP_USER: ${{ secrets.FTP_USER }}
        FTP_PASSWORD: ${{ secrets.FTP_PASSWORD }}
        FTP_PATH: ${{ secrets.FTP_PATH }}

    - name: üåê Deploy to GitHub Pages
      if: env.GITHUB_TOKEN != ''
      uses: peaceiris/actions-gh-pages@v4
      with:
        github_token: ${{ secrets.GITHUB_TOKEN }}
        publish_dir: ./deploy
        publish_branch: gh-pages
        force_orphan: true

    - name: ‚òÅÔ∏è Deploy to Netlify (if configured)
      if: env.NETLIFY_SITE_ID != ''
      run: |
        echo "‚òÅÔ∏è Deploying to Netlify..."

        # Install Netlify CLI
        npm install -g netlify-cli

        # Deploy to Netlify
        netlify deploy --prod --dir deploy --site $NETLIFY_SITE_ID --auth $NETLIFY_AUTH_TOKEN

        echo "‚úÖ Netlify deployment completed"
      env:
        NETLIFY_SITE_ID: ${{ secrets.NETLIFY_SITE_ID }}
        NETLIFY_AUTH_TOKEN: ${{ secrets.NETLIFY_AUTH_TOKEN }}

    - name: üéØ Deploy to Vercel (if configured)
      if: env.VERCEL_TOKEN != ''
      run: |
        echo "üéØ Deploying to Vercel..."

        # Install Vercel CLI
        npm install -g vercel

        # Deploy to Vercel
        cd deploy
        vercel --prod --token $VERCEL_TOKEN --yes

        echo "‚úÖ Vercel deployment completed"
      env:
        VERCEL_TOKEN: ${{ secrets.VERCEL_TOKEN }}
        VERCEL_ORG_ID: ${{ secrets.VERCEL_ORG_ID }}
        VERCEL_PROJECT_ID: ${{ secrets.VERCEL_PROJECT_ID }}

    - name: üìä Deployment summary
      run: |
        echo "üìä Deployment Summary"
        echo "===================="
        echo "‚úÖ Package prepared: $(find deploy/ -type f | wc -l) files"
        echo "üìÖ Timestamp: $(date)"
        echo "üîó Commit: $GITHUB_SHA"
        echo "üåø Branch: $GITHUB_REF_NAME"
        echo "üèóÔ∏è Build: $GITHUB_RUN_NUMBER"
        echo ""
        echo "üåê Deployment targets attempted:"
        [ -n "${{ secrets.FTP_HOST }}" ] && echo "  - FTP: ${{ secrets.FTP_HOST }}" || echo "  - FTP: Not configured"
        [ -n "${{ secrets.GITHUB_TOKEN }}" ] && echo "  - GitHub Pages: Enabled" || echo "  - GitHub Pages: Not configured"
        [ -n "${{ secrets.NETLIFY_SITE_ID }}" ] && echo "  - Netlify: ${{ secrets.NETLIFY_SITE_ID }}" || echo "  - Netlify: Not configured"
        [ -n "${{ secrets.VERCEL_TOKEN }}" ] && echo "  - Vercel: Enabled" || echo "  - Vercel: Not configured"

  release:
    name: üì¶ Create Release Assets
    runs-on: ubuntu-latest
    if: github.event_name == 'release'

    steps:
    - name: üì• Checkout code
      uses: actions/checkout@v6

    - name: üì¶ Create distribution package
      run: |
        # Create dist directory
        mkdir -p dist

        # Copy main files
        cp index.html dist/
        cp -r js/ dist/

        # Copy additional files if they exist
        [ -d tests/ ] && cp -r tests/ dist/ || echo "‚ö†Ô∏è No tests directory found"
        [ -f README.md ] && cp README.md dist/ || echo "‚ö†Ô∏è No README.md found"
        [ -f README.en.md ] && cp README.en.md dist/ || echo "‚ö†Ô∏è No README.en.md found"
        [ -f TODO.md ] && cp TODO.md dist/ || echo "‚ö†Ô∏è No TODO.md found"
        [ -f TECHNICAL_IMPROVEMENTS.md ] && cp TECHNICAL_IMPROVEMENTS.md dist/ || echo "‚ö†Ô∏è No TECHNICAL_IMPROVEMENTS.md found"
        [ -f version.json ] && cp version.json dist/ || echo "‚ö†Ô∏è No version.json found"
        [ -f LICENSE ] && cp LICENSE dist/ || echo "‚ö†Ô∏è No LICENSE found"

        # Create archive
        tar -czf beb-email-generator-${{ github.event.release.tag_name }}.tar.gz -C dist .
        zip -r beb-email-generator-${{ github.event.release.tag_name }}.zip dist/

    - name: üì§ Upload release assets
      uses: actions/upload-release-asset@v1
      env:
        GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
      with:
        upload_url: ${{ github.event.release.upload_url }}
        asset_path: ./beb-email-generator-${{ github.event.release.tag_name }}.tar.gz
        asset_name: beb-email-generator-${{ github.event.release.tag_name }}.tar.gz
        asset_content_type: application/gzip